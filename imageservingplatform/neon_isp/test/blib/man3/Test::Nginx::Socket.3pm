.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Nginx::Socket 3"
.TH Test::Nginx::Socket 3 "2014-06-15" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Nginx::Socket \- Socket\-backed test scaffold for the Nginx C modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test::Nginx::Socket;
\&
\&    plan tests => $Test::Nginx::Socket::RepeatEach * 2 * blocks();
\&
\&    run_tests();
\&
\&    _\|_DATA_\|_
\&
\&    === TEST 1: sanity
\&    \-\-\- config
\&        location /echo {
\&            echo_before_body hello;
\&            echo world;
\&        }
\&    \-\-\- request
\&        GET /echo
\&    \-\-\- response_body
\&    hello
\&    world
\&    \-\-\- error_code: 200
\&
\&
\&    === TEST 2: set Server
\&    \-\-\- config
\&        location /foo {
\&            echo hi;
\&            more_set_headers \*(AqServer: Foo\*(Aq;
\&        }
\&    \-\-\- request
\&        GET /foo
\&    \-\-\- response_headers
\&    Server: Foo
\&    \-\-\- response_body
\&    hi
\&
\&
\&    === TEST 3: clear Server
\&    \-\-\- config
\&        location /foo {
\&            echo hi;
\&            more_clear_headers \*(AqServer: \*(Aq;
\&        }
\&    \-\-\- request
\&        GET /foo
\&    \-\-\- response_headers_like
\&    Server: nginx.*
\&    \-\-\- response_body
\&    hi
\&
\&
\&    === TEST 3: chunk size too small
\&    \-\-\- config
\&        chunkin on;
\&        location /main {
\&            echo_request_body;
\&        }
\&    \-\-\- more_headers
\&    Transfer\-Encoding: chunked
\&    \-\-\- request eval
\&    "POST /main
\&    4\er
\&    hello\er
\&    0\er
\&    \er
\&    "
\&    \-\-\- error_code: 400
\&    \-\-\- response_body_like: 400 Bad Request
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a test scaffold based on non-blocking IO::Socket for automated testing in Nginx C module development.
.PP
This class inherits from Test::Base, thus bringing all its
declarative power to the Nginx C module testing practices.
.PP
You need to terminate or kill any Nginx processes before running the test suite if you have changed the Nginx server binary. Normally it's as simple as
.PP
.Vb 2
\&  killall nginx
\&  PATH=/path/to/your/nginx\-with\-memc\-module:$PATH prove \-r t
.Ve
.PP
This module will create a temporary server root under t/servroot/ of the current working directory and starts and uses the nginx executable in the \s-1PATH\s0 environment.
.PP
You will often want to look into \fIt/servroot/logs/error.log\fR
when things go wrong ;)
.SH "Sections supported"
.IX Header "Sections supported"
The following sections are supported:
.SS "config"
.IX Subsection "config"
Content of this section will be included in the \*(L"server\*(R" part of the generated
config file. This is the place where you want to put the \*(L"location\*(R" directive
enabling the module you want to test. Example:
.PP
.Vb 4
\&        location /echo {
\&            echo_before_body hello;
\&            echo world;
\&        }
.Ve
.PP
Sometimes you simply don't want to bother copying ten times the same
configuration for the ten tests you want to run against your module. One way
to do this is to write a config section only for the first test in your \f(CW\*(C`.t\*(C'\fR
file. All subsequent tests will re-use the same config. Please note that this
depends on the order of test, so you should run \f(CW\*(C`prove\*(C'\fR with variable
\&\f(CW\*(C`TEST_NGINX_NO_SHUFFLE=1\*(C'\fR (see below for more on this variable).
.PP
Please note that config section goes through environment variable expansion
provided the variables to expand start with \s-1TEST_NGINX\s0.
So, the following is a perfectly legal (provided \f(CW\*(C`TEST_NGINX_HTML_DIR\*(C'\fR is
set correctly):
.PP
.Vb 3
\&    location /main {
\&        echo_subrequest POST /sub \-f $TEST_NGINX_HTML_DIR/blah.txt;
\&    }
.Ve
.SS "http_config"
.IX Subsection "http_config"
Content of this section will be included in the \*(L"http\*(R" part of the generated
config file. This is the place where you want to put the \*(L"upstream\*(R" directive
you might want to test. Example:
.PP
.Vb 5
\&    upstream database {
\&        postgres_server     127.0.0.1:$TEST_NGINX_POSTGRESQL_PORT
\&                            dbname=ngx_test user=ngx_test
\&                            password=wrong_pass;
\&    }
.Ve
.PP
As you guessed from the example above, this section goes through environment
variable expansion (variables have to start with \s-1TEST_NGINX\s0).
.SS "main_config"
.IX Subsection "main_config"
Content of this section will be included in the \*(L"main\*(R" part of the generated
config file. This is very rarely used, except if you are testing nginx core
itself.
.PP
This section goes through environment
variable expansion (variables have to start with \s-1TEST_NGINX\s0).
.SS "request"
.IX Subsection "request"
This is probably the most important section. It defines the request(s) you
are going to send to the nginx server. It offers a pretty powerful grammar
which we are going to walk through one example at a time.
.PP
In its most basic form, this section looks like that:
.PP
.Vb 2
\&    \-\-\- request
\&    GET
.Ve
.PP
This will just do a \s-1GET\s0 request on the root (i.e. /) of the server using
\&\s-1HTTP/1\s0.1.
.PP
Of course, you might want to test something else than the root of your
web server and even use a different version of \s-1HTTP\s0. This is possible:
.PP
.Vb 2
\&    \-\-\- request
\&    GET /foo HTTP/1.0
.Ve
.PP
Please note that specifying \s-1HTTP/1\s0.0 will not prevent Test::Nginx from
sending the \f(CW\*(C`Host\*(C'\fR header. Actually Test::Nginx always sends 2 headers:
\&\f(CW\*(C`Host\*(C'\fR (with value localhost) and \f(CW\*(C`Connection\*(C'\fR (with value Close for
simple requests and keep-alive for all but the last pipelined_requests).
.PP
You can also add a content to your request:
.PP
.Vb 3
\&    \-\-\- request
\&    POST /foo
\&    Hello world
.Ve
.PP
Test::Nginx will automatically calculate the content length and add the
corresponding header for you.
.PP
This being said, as soon as you want to \s-1POST\s0 real data, you will be interested
in using the more_headers section and using the power of Test::Base filters
to urlencode the content you are sending. Which gives us a
slightly more realistic example:
.PP
.Vb 6
\&    \-\-\- more_headers
\&    Content\-type: application/x\-www\-form\-urlencoded
\&    \-\-\- request eval
\&    use URI::Escape;
\&    "POST /rrd/foo
\&    value=".uri_escape("N:12345")
.Ve
.PP
Sometimes a test is more than one request. Typically you want to \s-1POST\s0 some
data and make sure the data has been taken into account with a \s-1GET\s0. You can
do it using arrays:
.PP
.Vb 3
\&    \-\-\- request eval
\&    ["POST /users
\&    name=foo", "GET /users/foo"]
.Ve
.PP
This way, REST-like interfaces are pretty easy to test.
.PP
When you develop nifty nginx modules you will eventually want to test things
with buffers and \*(L"weird\*(R" network conditions. This is where you split
your request into network packets:
.PP
.Vb 2
\&    \-\-\- request eval
\&    [["POST /users\enna", "me=foo"]]
.Ve
.PP
Here, Test::Nginx will first send the request line, the headers it
automatically added for you and the first two letters of the body (\*(L"na\*(R" in
our example) in \s-1ONE\s0 network packet. Then, it will send the next packet (here
it's \*(L"me=foo\*(R"). When we talk about packets here, this is nto exactly correct
as there is no way to guarantee the behavior of the \s-1TCP/IP\s0 stack. What
Test::Nginx can guarantee is that this will result in two calls to
\&\f(CW\*(C`syswrite\*(C'\fR.
.PP
A good way to make \fIalmost\fR sure the two calls result in two packets is to
introduce a delay (let's say 2 seconds)before sending the second packet:
.PP
.Vb 2
\&    \-\-\- request eval
\&    [["POST /users\enna", {value => "me=foo", delay_before => 2}]]
.Ve
.PP
Of course, everything can be combined till your brain starts boiling ;) :
.PP
.Vb 7
\&    \-\-\- request eval
\&    use URI::Escape;
\&    my $val="value=".uri_escape("N:12346");
\&    [["POST /rrd/foo
\&    ".substr($val, 0, 6),
\&    {value => substr($val, 6, 5), delay_before=>5},
\&    substr($val, 11)],  "GET /rrd/foo"]
.Ve
.SS "request_eval"
.IX Subsection "request_eval"
Use of this section is deprecated and tests using it should replace it with
a \f(CW\*(C`request\*(C'\fR section with an \f(CW\*(C`eval\*(C'\fR filter. More explicitly:
.PP
.Vb 4
\&    \-\-\- request_eval
\&    "POST /echo_body
\&    hello\ex00\ex01\ex02
\&    world\ex03\ex04\exff"
.Ve
.PP
should be replaced by:
.PP
.Vb 4
\&    \-\-\- request eval
\&    "POST /echo_body
\&    hello\ex00\ex01\ex02
\&    world\ex03\ex04\exff"
.Ve
.SS "pipelined_requests"
.IX Subsection "pipelined_requests"
Specify pipelined requests that use a single keep-alive connection to the server.
.PP
Here is an example from ngx_lua's test suite:
.PP
.Vb 10
\&    === TEST 7: discard body
\&    \-\-\- config
\&        location = /foo {
\&            content_by_lua \*(Aq
\&                ngx.req.discard_body()
\&                ngx.say("body: ", ngx.var.request_body)
\&            \*(Aq;
\&        }
\&        location = /bar {
\&            content_by_lua \*(Aq
\&                ngx.req.read_body()
\&                ngx.say("body: ", ngx.var.request_body)
\&            \*(Aq;
\&        }
\&    \-\-\- pipelined_requests eval
\&    ["POST /foo
\&    hello, world",
\&    "POST /bar
\&    hiya, world"]
\&    \-\-\- response_body eval
\&    ["body: nil\en",
\&    "body: hiya, world\en"]
.Ve
.SS "more_headers"
.IX Subsection "more_headers"
Adds the content of this section as headers to the request being sent. Example:
.PP
.Vb 2
\&    \-\-\- more_headers
\&    X\-Foo: blah
.Ve
.PP
This will add \f(CW\*(C`X\-Foo: blah\*(C'\fR to the request (on top of the automatically
generated headers like \f(CW\*(C`Host\*(C'\fR, \f(CW\*(C`Connection\*(C'\fR and potentially
\&\f(CW\*(C`Content\-Length\*(C'\fR).
.SS "response_body"
.IX Subsection "response_body"
The expected value for the body of the submitted request.
.PP
.Vb 2
\&    \-\-\- response_body
\&    hello
.Ve
.PP
If the test is made of multiple requests, then the response_body \fB\s-1MUST\s0\fR
be an array and each request \fB\s-1MUST\s0\fR return the corresponding expected
body:
.PP
.Vb 4
\&    \-\-\- request eval
\&    ["GET /hello", "GET /world"]
\&    \-\-\- response_body eval
\&    ["hello", "world"]
.Ve
.SS "response_body_eval"
.IX Subsection "response_body_eval"
Use of this section is deprecated and tests using it should replace it
with a \f(CW\*(C`request\*(C'\fR section with an \f(CW\*(C`eval\*(C'\fR filter. Therefore:
.PP
.Vb 3
\&    \-\-\- response_body_eval
\&    "hello\ex00\ex01\ex02
\&    world\ex03\ex04\exff"
.Ve
.PP
should be replaced by:
.PP
.Vb 3
\&    \-\-\- response_body eval
\&    "hello\ex00\ex01\ex02
\&    world\ex03\ex04\exff"
.Ve
.SS "response_body_like"
.IX Subsection "response_body_like"
The body returned by the request \s-1MUST\s0 match the pattern provided by this
section. Example:
.PP
.Vb 2
\&    \-\-\- response_body_like
\&    ^elapsed 0\e.00[0\-5] sec\e.$
.Ve
.PP
If the test is made of multiple requests, then response_body_like \fB\s-1MUST\s0\fR
be an array and each request \fB\s-1MUST\s0\fR match the corresponding pattern.
.SS "response_headers"
.IX Subsection "response_headers"
The headers specified in this section are in the response sent by nginx.
.PP
.Vb 2
\&    \-\-\- response_headers
\&    Content\-Type: application/x\-resty\-dbd\-stream
.Ve
.PP
Of course, you can specify many headers in this section:
.PP
.Vb 3
\&    \-\-\- response_headers
\&    X\-Resty\-DBD\-Module:
\&    Content\-Type: application/x\-resty\-dbd\-stream
.Ve
.PP
The test will be successful only if all headers are found in the response with
the appropriate values.
.PP
If the test is made of multiple requests, then response_headers \fB\s-1MUST\s0\fR
be an array and each element of the array is checked against the
response to the corresponding request.
.SS "response_headers_like"
.IX Subsection "response_headers_like"
The value of the headers returned by nginx match the patterns.
.PP
.Vb 3
\&    \-\-\- response_headers_like
\&    X\-Resty\-DBD\-Module: ngx_drizzle \ed+\e.\ed+\e.\ed+
\&    Content\-Type: application/x\-resty\-dbd\-stream
.Ve
.PP
This will check that the response's \f(CW\*(C`Content\-Type\*(C'\fR is
application/x\-resty\-dbd\-stream and that the \f(CW\*(C`X\-Resty\-DBD\-Module\*(C'\fR matches
\&\f(CW\*(C`ngx_drizzle \ed+\e.\ed+\e.\ed+\*(C'\fR.
.PP
The test will be successful only if all headers are found in the response and
if the values match the patterns.
.PP
If the test is made of multiple requests, then response_headers_like \fB\s-1MUST\s0\fR
be an array and each element of the array is checked against the
response to the corresponding request.
.SS "raw_response_headers_like"
.IX Subsection "raw_response_headers_like"
Checks the headers part of the response against this pattern. This is
particularly useful when you want to write tests of redirect functions
that are not bound to the value of the port your nginx server (under
test) is listening to:
.PP
.Vb 1
\&    \-\-\- raw_response_headers_like: Location: http://localhost(?::\ed+)?/foo\er\en
.Ve
.PP
As usual, if the test is made of multiple requests, then
raw_response_headers_like \fB\s-1MUST\s0\fR be an array.
.SS "error_code"
.IX Subsection "error_code"
The expected value of the \s-1HTTP\s0 response code. If not set, this is assumed
to be 200. But you can expect other things such as a redirect:
.PP
.Vb 1
\&    \-\-\- error_code: 302
.Ve
.PP
If the test is made of multiple requests, then
error_code \fB\s-1MUST\s0\fR be an array with the expected value for the response status
of each request in the test.
.SS "error_code_like"
.IX Subsection "error_code_like"
Just like \f(CW\*(C`error_code\*(C'\fR, but accepts a Perl regex as the value, for example:
.PP
.Vb 1
\&    \-\-\- error_code_like: ^(?:500)?$
.Ve
.PP
If the test is made of multiple requests, then
error_code_like \fB\s-1MUST\s0\fR be an array with the expected value for the response status
of each request in the test.
.SS "timeout"
.IX Subsection "timeout"
Specify the timeout value (in seconds) for the \s-1HTTP\s0 client embedded into the test scaffold. This has nothing
to do with the server side configuration. When the timeout expires, the test scaffold will immediately
close the socket for connecting to the Nginx server being tested.
.PP
Note that, just as almost all the timeout settings in the Nginx world, this timeout
also specifies the maximum waiting time between two successive I/O events on the same socket handle,
rather than the total waiting time for the current socket operation.
.PP
When the timeout setting expires, a test failure will be
triggered with the message \*(L"\s-1ERROR:\s0 client socket timed out \- \s-1TEST\s0 \s-1NAME\s0\*(R", unless you have specified
\&\f(CW\*(C`\-\-\- abort\*(C'\fR at the same time.
.PP
Here is an example:
.PP
.Vb 11
\&    === TEST 1: test timeout
\&    \-\-\- location
\&        location = /t {
\&            echo_sleep 1;
\&            echo ok;
\&        }
\&    \-\-\- request
\&        GET /t
\&    \-\-\- response_body
\&    ok
\&    \-\-\- timeout: 1.5
.Ve
.PP
An optional time unit can be specified, for example,
.PP
.Vb 1
\&    \-\-\- timeout: 50ms
.Ve
.PP
Acceptable time units are \f(CW\*(C`s\*(C'\fR (seconds) and \f(CW\*(C`ms\*(C'\fR (milliseconds). If no time unit is specified, then default to seconds.
.SS "error_log"
.IX Subsection "error_log"
Checks if the pattern or multiple patterns all appear in lines of the \fIerror.log\fR file.
.PP
For example,
.PP
.Vb 10
\&    === TEST 1: matched with j
\&    \-\-\- config
\&        location /re {
\&            content_by_lua \*(Aq
\&                m = ngx.re.match("hello, 1234", "([0\-9]+)", "j")
\&                if m then
\&                    ngx.say(m[0])
\&                else
\&                    ngx.say("not matched!")
\&                end
\&            \*(Aq;
\&        }
\&    \-\-\- request
\&        GET /re
\&    \-\-\- response_body
\&    1234
\&    \-\-\- error_log: pcre JIT compiling result: 1
.Ve
.PP
Then the substring \*(L"pcre \s-1JIT\s0 compiling result: 1\*(R" must appear literally in a line of \fIerror.log\fR.
.PP
Multiple patterns are also supported, for example:
.PP
.Vb 2
\&    \-\-\- error_log eval
\&    ["abc", qr/blah/]
.Ve
.PP
then the substring \*(L"abc\*(R" must appear literally in a line of \fIerror.log\fR, and the regex \f(CW\*(C`qr/blah\*(C'\fR
must also match a line in \fIerror.log\fR.
.SS "abort"
.IX Subsection "abort"
Makes the test scaffold not to treat \f(CW\*(C`\-\-\- timeout\*(C'\fR expiration as a test failure.
.SS "shutdown"
.IX Subsection "shutdown"
Perform a \f(CW\*(C`shutdown\*(C'\fR() operaton on the client socket connecting to Nginx as soon as sending out
all the request data. This section takes an (optional) integer value for the argument to the
\&\f(CW\*(C`shutdown\*(C'\fR function call. For example,
.PP
.Vb 1
\&    \-\-\- shutdown: 1
.Ve
.PP
will make the connection stop sending data, which is the default.
.SS "no_error_log"
.IX Subsection "no_error_log"
Very much like the \f(CW\*(C`\-\-\- error_log\*(C'\fR section, but does the opposite test, i.e.,
pass only when the specified patterns of lines do not appear in the \fIerror.log\fR file at all.
.PP
Here is an example:
.PP
.Vb 2
\&    \-\-\- no_error_log
\&    [error]
.Ve
.PP
This test will fail when any of the line in the \fIerror.log\fR file contains the string \f(CW"[error]"\fR.
.PP
Just like the \f(CW\*(C`\-\-\- error_log\*(C'\fR section, one can also specify multiple patterns:
.PP
.Vb 2
\&    \-\-\- no_error_log eval
\&    ["abc", qr/blah/]
.Ve
.PP
Then if any line in \fIerror.log\fR contains the string \f(CW"abc"\fR or match the Perl regex \f(CW\*(C`qr/blah/\*(C'\fR, then the test will fail.
.SS "log_level"
.IX Subsection "log_level"
Overrides the default error log level for the current test block.
.PP
For example:
.PP
.Vb 1
\&    \-\-\- log_level: debug
.Ve
.PP
The default error log level can be specified in the Perl code by calling the `\fIlog_level()\fR` function, as in
.PP
.Vb 1
\&    use Test::Nginx::Socket;
\&
\&    repeat_each(2);
\&    plan tests => repeat_each() * (3 * blocks());
\&
\&    log_level(\*(Aqwarn\*(Aq);
\&
\&    run_tests();
\&
\&    _\|_DATA_\|_
\&    ...
.Ve
.SS "raw_request"
.IX Subsection "raw_request"
The exact request to send to nginx. This is useful when you want to test
soem behaviors that are not available with \*(L"request\*(R" such as an erroneous
\&\f(CW\*(C`Content\-Length\*(C'\fR header or splitting packets right in the middle of headers:
.PP
.Vb 7
\&    \-\-\- raw_request eval
\&    ["POST /rrd/taratata HTTP/1.1\er
\&    Host: localhost\er
\&    Connection: Close\er
\&    Content\-Type: application/",
\&    "x\-www\-form\-urlencoded\er
\&    Content\-Length:15\er\en\er\envalue=N%3A12345"]
.Ve
.PP
This can also be useful to tests \*(L"invalid\*(R" request lines:
.PP
.Vb 2
\&    \-\-\- raw_request
\&    GET /foo HTTP/2.0 THE_FUTURE_IS_NOW
.Ve
.SS "ignore_response"
.IX Subsection "ignore_response"
Do not attempt to parse the response or run the response related subtests.
.SS "user_files"
.IX Subsection "user_files"
With this section you can create a file that will be copied in the
html directory of the nginx server under test. For example:
.PP
.Vb 3
\&    \-\-\- user_files
\&    >>> blah.txt
\&    Hello, world
.Ve
.PP
will create a file named \f(CW\*(C`blah.txt\*(C'\fR in the html directory of the nginx
server tested. The file will contain the text \*(L"Hello, world\*(R".
.SS "skip_eval"
.IX Subsection "skip_eval"
Skip the specified number of subtests (in the current test block) if the result of running a piece of Perl code is true.
.PP
The format for this section is
.PP
.Vb 2
\&    \-\-\- skip_eval
\&    <subtest\-count>: <perl\-code>
.Ve
.PP
For example, to skip 3 subtests when the current operating system is not Linux:
.PP
.Vb 2
\&    \-\-\- skip_eval
\&    3: $^O ne \*(Aqlinux\*(Aq
.Ve
.PP
or equivalently,
.PP
.Vb 1
\&    \-\-\- skip_eval: 3: $^O ne \*(Aqlinux\*(Aq
.Ve
.SS "skip_nginx"
.IX Subsection "skip_nginx"
Skip the specified number of subtests (in the current test block)
for the specified version range of nginx.
.PP
The format for this section is
.PP
.Vb 2
\&    \-\-\- skip_nginx
\&    <subtest\-count>: <op> <version>
.Ve
.PP
The <subtest\-count> value must be a positive integer.
The <op> value could be either \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`>=\*(C'\fR, \f(CW\*(C`<\*(C'\fR, or \f(CW\*(C`<=\*(C'\fR. the <version> part is a valid nginx version number, like \f(CW1.0.2\fR.
.PP
An example is
.PP
.Vb 8
\&    === TEST 1: sample
\&    \-\-\- config
\&        location /t { echo hello; }
\&    \-\-\- request
\&        GET /t
\&    \-\-\- response_body
\&    \-\-\- skip_nginx
\&    2: < 0.8.54
.Ve
.PP
That is, skipping 2 subtests in this test block for nginx versions older than 0.8.54.
.PP
This \f(CW\*(C`skip_nginx\*(C'\fR section only allows you to specify one boolean expression as
the skip condition. If you want to use two boolean expressions, you should use the \f(CW\*(C`skip_nginx2\*(C'\fR section instead.
.SS "skip_nginx2"
.IX Subsection "skip_nginx2"
This seciton is similar to \f(CW\*(C`skip_nginx\*(C'\fR, but the skip condition consists of two boolean expressions joined by the operator \f(CW\*(C`and\*(C'\fR or \f(CW\*(C`or\*(C'\fR.
.PP
The format for this section is
.PP
.Vb 2
\&    \-\-\- skip_nginx2
\&    <subtest\-count>: <op> <version> and|or <op> <version>
.Ve
.PP
For example:
.PP
.Vb 8
\&    === TEST 1: sample
\&    \-\-\- config
\&        location /t { echo hello; }
\&    \-\-\- request
\&        GET /t
\&    \-\-\- response_body
\&    \-\-\- skip_nginx2
\&    2: < 0.8.53 and >= 0.8.41
.Ve
.SS "stap"
.IX Subsection "stap"
This section is used to specify user systemtap script file (.stp file)
.PP
Here's an example:
.PP
.Vb 10
\&    === TEST 1: stap sample
\&    \-\-\- config
\&        location /t { echo hello; }
\&    \-\-\- stap
\&    probe process("nginx").function("ngx_http_finalize_request")
\&    {
\&        printf("finalize %s?%s\en", ngx_http_req_uri($r),
\&               ngx_http_req_args($r))
\&    }
\&    \-\-\- stap_out
\&    finalize /test?a=3&b=4
\&    \-\-\- request
\&    GET /test?a=3&b=4
\&    \-\-\- response_body
\&    hello
.Ve
.PP
There's some macros that can be used in the \*(L"\-\-\- stap\*(R" section value. These macros
will be expanded by the test scaffold automatically.
.ie n .IP """F(function_name)""" 4
.el .IP "\f(CWF(function_name)\fR" 4
.IX Item "F(function_name)"
This expands to \f(CW\*(C`probe process("nginx").function("function_name")\*(C'\fR. For example,
 the sample above can be rewritten as
.Sp
.Vb 10
\&    === TEST 1: stap sample
\&    \-\-\- config
\&        location /t { echo hello; }
\&    \-\-\- stap
\&    F(ngx_http_finalize_request)
\&    {
\&        printf("finalize %s?%s\en", ngx_http_req_uri($r),
\&               ngx_http_req_args($r))
\&    }
\&    \-\-\- stap_out
\&    finalize /test?a=3&b=4
\&    \-\-\- request
\&    GET /test?a=3&b=4
\&    \-\-\- response_body
\&    hello
.Ve
.ie n .IP """T()""" 4
.el .IP "\f(CWT()\fR" 4
.IX Item "T()"
This macro will be expanded to \f(CW\*(C`println("Fire ", pp())\*(C'\fR.
.ie n .IP """M(static\-probe\-name)""" 4
.el .IP "\f(CWM(static\-probe\-name)\fR" 4
.IX Item "M(static-probe-name)"
This macro will be expanded to \f(CW\*(C`probe process("nginx").mark("static\-probe\-name")\*(C'\fR.
.Sp
For example,
.Sp
.Vb 4
\&    M(http\-subrequest\-start)
\&    {
\&        ...
\&    }
.Ve
.Sp
will be expanded to
.Sp
.Vb 4
\&    probe process("nginx").mark("http\-subrequest\-start")
\&    {
\&        ...
\&    }
.Ve
.SS "stap_out"
.IX Subsection "stap_out"
This seciton specifies the expected literal output of the systemtap script specified by \f(CW\*(C`stap\*(C'\fR.
.SS "stap_out_like"
.IX Subsection "stap_out_like"
Just like \f(CW\*(C`stap_out\*(C'\fR, but specify a Perl regex pattern instead.
.SS "wait"
.IX Subsection "wait"
Takes an integer value for the seconds of time to wait right after processing the Nginx response and
before performing the error log and systemtap output checks.
.SS "udp_listen"
.IX Subsection "udp_listen"
Instantiates a \s-1UDP\s0 server listening on the port specified in the background for the test
case to access. The server will be started and shut down at each iteration of the test case
(if repeat_each is set to 3, then there are 3 iterations).
.PP
The \s-1UDP\s0 server will first read and discard a datagram and then send back a datagram with the content
specified by the \f(CW\*(C`udp_reply\*(C'\fR section value.
.PP
Here is an example:
.PP
.Vb 10
\&    === TEST 1: udp access
\&    \-\-\- config
\&        location = /t {
\&            content_by_lua \*(Aq
\&                local udp = ngx.socket.udp()
\&                udp:setpeername("127.0.0.1", 19232)
\&                udp:send("blah")
\&                local data, err = udp:receive()
\&                ngx.say("received: ", data)
\&            \*(Aq;
\&        }
\&    \-\-\- udp_listen: 19232
\&    \-\-\- udp_reply: hello world
\&    \-\-\- request
\&    GET /t
\&    \-\-\- response_body
\&    received: hello world
.Ve
.PP
Datagram \s-1UNIX\s0 domain socket is also supported if a path name ending with \*(L".sock\*(R" is given to this directive. For instance,
.PP
.Vb 10
\&    === TEST 2: datagram unix domain socket access
\&    \-\-\- config
\&        location = /t {
\&            content_by_lua \*(Aq
\&                local udp = ngx.socket.udp()
\&                udp:setpeername("unix:a.sock")
\&                udp:send("blah")
\&                local data, err = udp:receive()
\&                ngx.say("received: ", data)
\&            \*(Aq;
\&        }
\&    \-\-\- udp_listen: a.sock
\&    \-\-\- udp_reply: hello world
\&    \-\-\- request
\&    GET /t
\&    \-\-\- response_body
\&    received: hello world
.Ve
.SS "udp_reply"
.IX Subsection "udp_reply"
This section specifies the datagram reply content for the \s-1UDP\s0 server created by the \f(CW\*(C`udp_listen\*(C'\fR section.
.PP
You can also specify a delay time before sending out the reply via the \f(CW\*(C`udp_reply_delay\*(C'\fR section. By default, there is no delay.
.PP
An array value can be specified to make the embedded \s-1UDP\s0 server to send mulitple replies as specified, for example:
.PP
.Vb 2
\&    \-\-\- udp_reply eval
\&    [ "hello", "world" ]
.Ve
.PP
See the \f(CW\*(C`udp_listen\*(C'\fR section for more details.
.SS "udp_reply_delay"
.IX Subsection "udp_reply_delay"
This section specifies the delay time before sending out the reply specified by the \f(CW\*(C`udp_reply\*(C'\fR section.
.PP
It is \f(CW0\fR delay by default.
.PP
An optional time unit can be specified, for example,
.PP
.Vb 1
\&    \-\-\- udp_reply_delay: 50ms
.Ve
.PP
Acceptable time units are \f(CW\*(C`s\*(C'\fR (seconds) and \f(CW\*(C`ms\*(C'\fR (milliseconds). If no time unit is specified, then default to seconds.
.SS "udp_query"
.IX Subsection "udp_query"
Tests whether the \s-1UDP\s0 query sent to the embedded \s-1UDP\s0 server is equal to what is specified by this directive.
.PP
For example,
.PP
.Vb 10
\&    === TEST 1: udp access
\&    \-\-\- config
\&        location = /t {
\&            content_by_lua \*(Aq
\&                local udp = ngx.socket.udp()
\&                udp:setpeername("127.0.0.1", 19232)
\&                udp:send("blah")
\&                local data, err = udp:receive()
\&                ngx.say("received: ", data)
\&            \*(Aq;
\&        }
\&    \-\-\- udp_listen: 19232
\&    \-\-\- udp_reply: hello world
\&    \-\-\- request
\&    GET /t
\&    \-\-\- udp_query: hello world
\&    \-\-\- response_body
\&    received: hello world
.Ve
.SS "tcp_listen"
.IX Subsection "tcp_listen"
Just like \f(CW\*(C`udp_listen\*(C'\fR, but starts an embedded \s-1TCP\s0 server listening on the port specified.
.SS "tcp_no_close"
.IX Subsection "tcp_no_close"
When this section is present, the embedded \s-1TCP\s0 server (if any) will not close
the current \s-1TCP\s0 connection.
.SS "tcp_reply_delay"
.IX Subsection "tcp_reply_delay"
Just like \f(CW\*(C`udp_reply_delay\*(C'\fR, but for the embedded \s-1TCP\s0 server.
.SS "tcp_reply"
.IX Subsection "tcp_reply"
Just like \f(CW\*(C`tcp_reply\*(C'\fR, but for the embedded \s-1TCP\s0 server.
.SS "tcp_query"
.IX Subsection "tcp_query"
Just like \f(CW\*(C`udp_query\*(C'\fR, but for the embedded \s-1TCP\s0 server.
.SS "tcp_query_len"
.IX Subsection "tcp_query_len"
Specifies the expected \s-1TCP\s0 query received by the embedded \s-1TCP\s0 server.
.SS "raw_request_middle_delay"
.IX Subsection "raw_request_middle_delay"
Delay in sec between sending successive packets in the \*(L"raw_request\*(R" array
value. Also used when a request is split in packets.
.SH "Environment variables"
.IX Header "Environment variables"
All environment variables starting with \f(CW\*(C`TEST_NGINX_\*(C'\fR are expanded in the
sections used to build the configuration of the server that tests automatically
starts. The following environment variables are supported by this module:
.SS "\s-1TEST_NGINX_VERBOSE\s0"
.IX Subsection "TEST_NGINX_VERBOSE"
Controls whether to output verbose debugging messages in Test::Nginx. Default to empty.
.SS "\s-1TEST_NGINX_CHECK_LEAK\s0"
.IX Subsection "TEST_NGINX_CHECK_LEAK"
When set to 1, the test scaffold performs the most general memory
leak test by means of calling \f(CW\*(C`weighttpd\*(C'\fR/\f(CW\*(C`ab\*(C'\fR and \f(CW\*(C`ps\*(C'\fR.
.PP
Specifically, it starts \f(CW\*(C`weighttp\*(C'\fR (for \s-1HTTP\s0 1.1 \f(CW\*(C`GET\*(C'\fR requests) or
\&\f(CW\*(C`ab\*(C'\fR (for \s-1HTTP\s0 1.0 requests) to repeatedly hitting Nginx for
seconds in a sub-process, and then after about 1 second, it will
start sampling the \s-1RSS\s0 value of the Nginx process by calling
the \f(CW\*(C`ps\*(C'\fR utility every 20 ms. Finally, it will output all
the sample point data and the
line slope of the linear regression result on the 100 sample points.
.PP
One typical output for non-leaking test cases:
.PP
.Vb 10
\&    t/075\-logby.t .. 3/17 TEST 2: log_by_lua_file
\&    LeakTest: [2176 2176 2176 2176 2176 2176 2176
\&     2176 2176 2176 2176 2176 2176 2176 2176 2176
\&     2176 2176 2176 2176 2176 2176 2176 2176 2176
\&     2176 2176 2176 2176 2176 2176 2176 2176 2176
\&     2176 2176 2176 2176 2176 2176 2176 2176 2176
\&     2176 2176 2176 2176 2176 2176 2176 2176 2176
\&     2176 2176 2176 2176 2176 2176 2176 2176 2176
\&     2176 2176 2176 2176 2176 2176 2176 2176 2176
\&     2176 2176 2176 2176 2176 2176 2176 2176 2176
\&     2176 2176 2176 2176 2176 2176 2176 2176 2176
\&     2176 2176 2176 2176 2176 2176 2176 2176 2176
\&     2176 2176 2176]
\&    LeakTest: k=0.0
.Ve
.PP
and here is an example of leaking:
.PP
.Vb 10
\&    TEST 5: ngx.ctx available in log_by_lua (not defined yet)
\&    LeakTest: [4396 4440 4476 4564 4620 4708 4752
\&     4788 4884 4944 4996 5032 5080 5132 5188 5236
\&     5348 5404 5464 5524 5596 5652 5700 5776 5828
\&     5912 5964 6040 6108 6108 6316 6316 6584 6672
\&     6672 6752 6820 6912 6912 6980 7064 7152 7152
\&     7240 7340 7340 7432 7508 7508 7600 7700 7700
\&     7792 7896 7896 7992 7992 8100 8100 8204 8296
\&     8296 8416 8416 8512 8512 8624 8624 8744 8744
\&     8848 8848 8968 8968 9084 9084 9204 9204 9324
\&     9324 9444 9444 9584 9584 9704 9704 9832 9832
\&     9864 9964 9964 10096 10096 10488 10488 10488
\&     10488 10488 11052 11052]
\&    LeakTest: k=64.1
.Ve
.PP
Even very small leaks can be amplified and caught easily by this
testing mode because their slopes will usually be far above \f(CW1.0\fR.
.PP
For now, only \f(CW\*(C`GET\*(C'\fR, \f(CW\*(C`POST\*(C'\fR, \f(CW\*(C`PUT\*(C'\fR, and \f(CW\*(C`HEAD\*(C'\fR requests are supported
(due to the limited \s-1HTTP\s0 support in both \f(CW\*(C`ab\*(C'\fR and \f(CW\*(C`weighttp\*(C'\fR).
Other methods specified in the test cases will turn to \f(CW\*(C`GET\*(C'\fR with force.
.PP
The tests in this mode will always succeed because this mode also
enforces the \*(L"dry-run\*(R" mode.
.SS "\s-1TEST_NGINX_USE_HUP\s0"
.IX Subsection "TEST_NGINX_USE_HUP"
When set to 1, the test scaffold will try to send \f(CW\*(C`HUP\*(C'\fR signal to the
Nginx master process to reload the config file between
successive test blocks (but not successive \f(CW\*(C`repeast_each\*(C'\fR
sub-tests within the same test block). When this envirnoment is set
to 1, it will also enfornce the \*(L"master_process on\*(R" config line
in the \fInginx.conf\fR file,
because Nginx is buggy in processing \s-1HUP\s0 signal when the master process is off.
.SS "\s-1TEST_NGINX_POSTPONE_OUTPUT\s0"
.IX Subsection "TEST_NGINX_POSTPONE_OUTPUT"
Defaults to empty. This environment takes positive integer numbers as its value and it will cause the auto-generated nginx.conf file to have a \*(L"postpone_output\*(R" setting in the http {} block.
.PP
For example, setting \s-1TEST_NGINX_POSTPONE_OUTPUT\s0 to 1 will have the following line in nginx.conf's http {} block:
.PP
.Vb 1
\&    postpone_output 1;
.Ve
.PP
and it will effectively disable the write buffering in nginx's ngx_http_write_module.
.SS "\s-1TEST_NGINX_NO_CLEAN\s0"
.IX Subsection "TEST_NGINX_NO_CLEAN"
When this environment is set to 1, it will prevent the test scaffold from quitting the Nginx server
at the end of the run. This is very useful when you want to use other tools like gdb or curl
inspect the Nginx server manually afterwards.
.SS "\s-1TEST_NGINX_NO_NGINX_MANAGER\s0"
.IX Subsection "TEST_NGINX_NO_NGINX_MANAGER"
Defaults to 0. If set to 1, Test::Nginx module will not manage
(configure/start/stop) the \f(CW\*(C`nginx\*(C'\fR process. Can be useful to run tests
against an already configured (and running) nginx server.
.SS "\s-1TEST_NGINX_NO_SHUFFLE\s0"
.IX Subsection "TEST_NGINX_NO_SHUFFLE"
Dafaults to 0. If set to 1, will make sure the tests are run in the order
they appear in the test file (and not in random order).
.SS "\s-1TEST_NGINX_USE_VALGRIND\s0"
.IX Subsection "TEST_NGINX_USE_VALGRIND"
If set, Test::Nginx will start nginx with valgrind with the the value of this environment as the options.
.PP
Nginx is actually started with
\&\f(CW\*(C`valgrind \-q $TEST_NGINX_USE_VALGRIND \-\-gen\-suppressions=all \-\-suppressions=valgrind.suppress\*(C'\fR,
the suppressions option being used only if there is actually
a valgrind.suppress file.
.PP
If this environment is set to the number \f(CW1\fR or any other
non-zero numbers, then it is equivalent to taking the value
\&\f(CW\*(C`\-\-tool=memcheck \-\-leak\-check=full\*(C'\fR.
.SS "\s-1TEST_NGINX_USE_STAP\s0"
.IX Subsection "TEST_NGINX_USE_STAP"
When set to true values (like 1), the test scaffold will use systemtap to instrument the nginx
process.
.PP
You can specify the stap script in the \f(CW\*(C`stap\*(C'\fR section.
.PP
Note that you need to use the \f(CW\*(C`stap\-nginx\*(C'\fR script from the \f(CW\*(C`nginx\-dtrace\*(C'\fR project.
.SS "\s-1TEST_NGINX_STAP_OUT\s0"
.IX Subsection "TEST_NGINX_STAP_OUT"
You can specify the output file for the systemtap tool. By default, a random file name
under the system temporary directory is generated.
.PP
It's common to specify \f(CW\*(C`TEST_NGINX_STAP_OUT=/dev/stderr\*(C'\fR when debugging.
.SS "\s-1TEST_NGINX_BINARY\s0"
.IX Subsection "TEST_NGINX_BINARY"
The command to start nginx. Defaults to \f(CW\*(C`nginx\*(C'\fR. Can be used as an alternative
to setting \f(CW\*(C`PATH\*(C'\fR to run a specific nginx instance.
.SS "\s-1TEST_NGINX_LOG_LEVEL\s0"
.IX Subsection "TEST_NGINX_LOG_LEVEL"
Value of the last argument of the \f(CW\*(C`error_log\*(C'\fR configuration directive.
Defaults to \f(CW\*(C`debug\*(C'\fR.
.SS "\s-1TEST_NGINX_MASTER_PROCESS\s0"
.IX Subsection "TEST_NGINX_MASTER_PROCESS"
Value of the \f(CW\*(C`master_process\*(C'\fR configuration directive. Defaults to \f(CW\*(C`off\*(C'\fR.
.SS "\s-1TEST_NGINX_SERVER_PORT\s0"
.IX Subsection "TEST_NGINX_SERVER_PORT"
Value of the port the server started by Test::Nginx will listen to. If not
set, \f(CW\*(C`TEST_NGINX_PORT\*(C'\fR is used. If \f(CW\*(C`TEST_NGINX_PORT\*(C'\fR is not set,
then \f(CW1984\fR is used. See below for typical use.
.SS "\s-1TEST_NGINX_CLIENT_PORT\s0"
.IX Subsection "TEST_NGINX_CLIENT_PORT"
Value of the port Test::Nginx will diirect requests to. If not
set, \f(CW\*(C`TEST_NGINX_PORT\*(C'\fR is used. If \f(CW\*(C`TEST_NGINX_PORT\*(C'\fR is not set,
then \f(CW1984\fR is used. A typical use of this feature is to test extreme
network conditions by adding a \*(L"proxy\*(R" between Test::Nginx and nginx
itself. This is described in the \f(CW\*(C`etcproxy integration\*(C'\fR section of this
module \s-1README\s0.
.SS "\s-1TEST_NGINX_PORT\s0"
.IX Subsection "TEST_NGINX_PORT"
A shortcut for setting both \f(CW\*(C`TEST_NGINX_CLIENT_PORT\*(C'\fR and
\&\f(CW\*(C`TEST_NGINX_SERVER_PORT\*(C'\fR.
.SS "\s-1TEST_NGINX_SLEEP\s0"
.IX Subsection "TEST_NGINX_SLEEP"
How much time (in seconds) should Test::Nginx sleep between two calls to \f(CW\*(C`syswrite\*(C'\fR when
sending request data. Defaults to 0.
.SS "\s-1TEST_NGINX_FORCE_RESTART_ON_TEST\s0"
.IX Subsection "TEST_NGINX_FORCE_RESTART_ON_TEST"
Defaults to 1. If set to 0, Test::Nginx will not restart the nginx
server when the config does not change between two tests.
.SS "\s-1TEST_NGINX_SERVROOT\s0"
.IX Subsection "TEST_NGINX_SERVROOT"
The root of the nginx \*(L"hierarchy\*(R" (where you find the conf, *_tmp and logs
directories). This value will be used with the \f(CW\*(C`\-p\*(C'\fR option of \f(CW\*(C`nginx\*(C'\fR.
Defaults to appending \f(CW\*(C`t/servroot\*(C'\fR to the current directory.
.SS "\s-1TEST_NGINX_IGNORE_MISSING_DIRECTIVES\s0"
.IX Subsection "TEST_NGINX_IGNORE_MISSING_DIRECTIVES"
If set to 1 will \s-1SKIP\s0 all tests which \f(CW\*(C`config\*(C'\fR sections resulted in a
\&\f(CW\*(C`unknown directive\*(C'\fR when trying to start \f(CW\*(C`nginx\*(C'\fR. Useful when you want to
run tests on a build of nginx that does not include all modules it should.
By default, these tests will \s-1FAIL\s0.
.SS "\s-1TEST_NGINX_EVENT_TYPE\s0"
.IX Subsection "TEST_NGINX_EVENT_TYPE"
This environment can be used to specify a event \s-1API\s0 type to be used by Nginx. Possible values are \f(CW\*(C`epoll\*(C'\fR, \f(CW\*(C`kqueue\*(C'\fR, \f(CW\*(C`select\*(C'\fR, \f(CW\*(C`rtsig\*(C'\fR, \f(CW\*(C`poll\*(C'\fR, and others.
.PP
For example,
.PP
.Vb 1
\&    $ TEST_NGINX_EVENT_TYPE=select prove \-r t
.Ve
.SS "\s-1TEST_NGINX_ERROR_LOG\s0"
.IX Subsection "TEST_NGINX_ERROR_LOG"
Error log files from all tests will be appended to the file specified with
this variable. There is no default value which disables the feature. This
is very useful when debugging. By default, each test triggers a start/stop
cycle for \f(CW\*(C`nginx\*(C'\fR. All logs are removed before each restart, so you can
only see the logs for the last test run (which you usually do not control
except if you set \f(CW\*(C`TEST_NGINX_NO_SHUFFLE=1\*(C'\fR). With this, you accumulate
all logs into a single file that is never cleaned up by Test::Nginx.
.SH "Samples"
.IX Header "Samples"
You'll find live samples in the following Nginx 3rd\-party modules:
.IP "ngx_echo" 4
.IX Item "ngx_echo"
http://github.com/agentzh/echo\-nginx\-module <http://github.com/agentzh/echo-nginx-module>
.IP "ngx_chunkin" 4
.IX Item "ngx_chunkin"
<http://wiki.nginx.org/NginxHttpChunkinModule>
.IP "ngx_memc" 4
.IX Item "ngx_memc"
<http://wiki.nginx.org/NginxHttpMemcModule>
.IP "ngx_drizzle" 4
.IX Item "ngx_drizzle"
http://github.com/chaoslawful/drizzle\-nginx\-module <http://github.com/chaoslawful/drizzle-nginx-module>
.IP "ngx_rds_json" 4
.IX Item "ngx_rds_json"
http://github.com/agentzh/rds\-json\-nginx\-module <http://github.com/agentzh/rds-json-nginx-module>
.IP "ngx_xss" 4
.IX Item "ngx_xss"
http://github.com/agentzh/xss\-nginx\-module <http://github.com/agentzh/xss-nginx-module>
.IP "ngx_srcache" 4
.IX Item "ngx_srcache"
http://github.com/agentzh/srcache\-nginx\-module <http://github.com/agentzh/srcache-nginx-module>
.IP "ngx_lua" 4
.IX Item "ngx_lua"
http://github.com/chaoslawful/lua\-nginx\-module <http://github.com/chaoslawful/lua-nginx-module>
.IP "ngx_set_misc" 4
.IX Item "ngx_set_misc"
http://github.com/agentzh/set\-misc\-nginx\-module <http://github.com/agentzh/set-misc-nginx-module>
.IP "ngx_array_var" 4
.IX Item "ngx_array_var"
http://github.com/agentzh/array\-var\-nginx\-module <http://github.com/agentzh/array-var-nginx-module>
.IP "ngx_form_input" 4
.IX Item "ngx_form_input"
http://github.com/calio/form\-input\-nginx\-module <http://github.com/calio/form-input-nginx-module>
.IP "ngx_iconv" 4
.IX Item "ngx_iconv"
http://github.com/calio/iconv\-nginx\-module <http://github.com/calio/iconv-nginx-module>
.IP "ngx_set_cconv" 4
.IX Item "ngx_set_cconv"
http://github.com/liseen/set\-cconv\-nginx\-module <http://github.com/liseen/set-cconv-nginx-module>
.IP "ngx_postgres" 4
.IX Item "ngx_postgres"
<http://github.com/FRiCKLE/ngx_postgres>
.IP "ngx_coolkit" 4
.IX Item "ngx_coolkit"
<http://github.com/FRiCKLE/ngx_coolkit>
.SH "SOURCE REPOSITORY"
.IX Header "SOURCE REPOSITORY"
This module has a Git repository on Github, which has access for all.
.PP
.Vb 1
\&    http://github.com/agentzh/test\-nginx
.Ve
.PP
If you want a commit bit, feel free to drop me a line.
.SH "DEBIAN PACKAGES"
.IX Header "DEBIAN PACKAGES"
Anto\*'nio P. P. Almeida is maintaining a Debian package for this module
in his Debian repository: http://debian.perusio.net
.SH "AUTHORS"
.IX Header "AUTHORS"
Yichun \*(L"agentzh\*(R" Zhang (\s-1XXX\s0) \f(CW\*(C`<agentzh@gmail.com>\*(C'\fR
.PP
Antoine \s-1BONAVITA\s0 \f(CW\*(C`<antoine.bonavita@gmail.com>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2009\-2012, agentzh \f(CW\*(C`<agentzh@gmail.com>\*(C'\fR.
.PP
Copyright (c) 2011\-2012, Antoine \s-1BONAVITA\s0 \f(CW\*(C`<antoine.bonavita@gmail.com>\*(C'\fR.
.PP
This module is licensed under the terms of the \s-1BSD\s0 license.
.PP
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
.IP "\(bu" 4
Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
.IP "\(bu" 4
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
.IP "\(bu" 4
Neither the name of the authors nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
.PP
\&\s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \s-1BY\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1AND\s0 \s-1CONTRIBUTORS\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1AND\s0 \s-1ANY\s0 \s-1EXPRESS\s0 \s-1OR\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0, \s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1ARE\s0 \s-1DISCLAIMED\s0. \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0 \s-1OR\s0 \s-1CONTRIBUTORS\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1DIRECT\s0, \s-1INDIRECT\s0, \s-1INCIDENTAL\s0, \s-1SPECIAL\s0, \s-1EXEMPLARY\s0, \s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 (\s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1PROCUREMENT\s0 \s-1OF\s0 \s-1SUBSTITUTE\s0 \s-1GOODS\s0 \s-1OR\s0 \s-1SERVICES\s0; \s-1LOSS\s0 \s-1OF\s0 \s-1USE\s0, \s-1DATA\s0, \s-1OR\s0 \s-1PROFITS\s0; \s-1OR\s0 \s-1BUSINESS\s0 \s-1INTERRUPTION\s0) \s-1HOWEVER\s0 \s-1CAUSED\s0 \s-1AND\s0 \s-1ON\s0 \s-1ANY\s0 \s-1THEORY\s0 \s-1OF\s0 \s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1CONTRACT\s0, \s-1STRICT\s0 \s-1LIABILITY\s0, \s-1OR\s0 \s-1TORT\s0 (\s-1INCLUDING\s0 \s-1NEGLIGENCE\s0 \s-1OR\s0 \s-1OTHERWISE\s0) \s-1ARISING\s0 \s-1IN\s0 \s-1ANY\s0 \s-1WAY\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OF\s0 \s-1THIS\s0 \s-1SOFTWARE\s0, \s-1EVEN\s0 \s-1IF\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0 \s-1SUCH\s0 \s-1DAMAGE\s0.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Nginx::LWP, Test::Base.
